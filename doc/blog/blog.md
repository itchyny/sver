# 同じビルドやテストを二度と実行しない方法

GitHub Actions で同じビルドやテストを二度と実行しない方法を紹介します。  
ホストランナーを ubuntu-linux にした場合、実行する必要のないジョブは 6 秒程度でスキップ可能です。

**注意** このブログは自作のツール [sver][] の宣伝が含まれます。

## Summary

- ビルドやテストの CI のジョブに再現性がある場合は複数回実行しても意味がない
- ジョブが依存する環境やソースコードを元にハッシュ値を計算することで同等なジョブに一意なラベルをつけられる
- ジョブ実行後に実行済みラベルを artifact として保存しておくことで後続の同等なジョブをスキップできる

## 同じビルドやテストを何度も実行してしまう

開発時に CI/CD を行うことが一般的になった現代では push や pull req、タグ付けなど様々なイベント毎にビルドやテストを実行します。
また monorepo のように複数のサービスを 1 つのリポジトリにまとめるプラクティスの適用もマイクロサービスの興隆の状況下で増えてきています。

その結果、リポジトリ内でのある変更が CI の結果に影響を及ぼさないことが明らかな場合でも何度もビルドやテストを実行してしまうという状況が発生してしまいます。  
これらはスローテスト問題や計算資源の大量消費として、時間と費用の両面で開発コストを押し上げます。

ビルドやテストが無駄になってしまう例としては、`ある修正を入れて push` → `間違いに気づき revert して push` などがあります。この場合、修正を入れる前に CI が通っていたのならば revert 後に再度 CI を実行する必要はありません。

![同じリビジョンならリビルド不要](build-dup.drawio.svg)

あるいは、リポジトリ上の README.md やドキュメントを編集したときにビルドやテストなどの CI が走っても無駄なことが多いでしょう。

ただし、同じソースコードに対して複数回ジョブを流すことが無駄と言えるのはジョブに再現性がある場合です。  
再現性があるとは、同じ入力(ソースコードや環境)であれば何度そのジョブを流しても同じ結果になるという事です。

## 同じ入力に対して一意なラベルをつけよう

ジョブに再現性があるという前提の下では、過去のビルド結果を保存しておけばそのジョブはスキップ可能です。  
ですが、過去のビルドと現在のビルドは同じものかどのように照合すればよいでしょう。

これは、ジョブの入力に対して一意なラベルをつけることで照合可能です。  
ジョブの入力とは、そのジョブで使われるソースコード一式とジョブが実行される環境です。  
GitHub Actions などリポジトリにジョブの定義ファイルを配置するタイプの CI ツールであれば環境もソースコードとみなして扱うことができます。  

> GitHub Actions でホストランナーを `runs-on: ubuntu-latest` など指定した場合に環境が一意と呼べるかについては、求める一意性の厳密さ次第です。

ではジョブの入力に対して一意なラベルをつけるにはどのような方法があるでしょうか。

![この2つに同じラベルを付けたい](add-label.drawio.svg)

簡易的にはツリーオブジェクトのハッシュ値を用いる方法があります。`git rev-parse HEAD^{tree}` で計算可能です。  
["同じソースツリーでテストが通っていたらテストをスキップする"][skip-test-blog] というブログでも git コマンドと S3 を用いる手法が紹介されています。

この手法を用いると、ブランチ違いの同一ジョブ、push・pull-request といったイベント違いの同一ジョブの実行を抑制することができます。

ただし、ジョブの成果物に影響のない変更でもハッシュが変わってしまうため、ドキュメントをリポジトリに入れていたり、monorepo のように多数のサービスが含まれるリポジトリでは `git rev-parse HEAD^{tree}` でも十分ではありません。

ジョブごとにビルドに関係するファイル `echo <ビルドに使われるファイルのリスト> | xargs -I@ cat "@" | sha256sum` のような処理でハッシュ値を計算することで、リビジョンやブランチに左右されないそのジョブ固有の値が得られます。

`<ビルドに使われるファイルのリスト>` を洗い出してハッシュ値を計算するのは面倒なので、そちらを簡略する方法についてはツール[sver][]を紹介します。

## 実行結果のラベルを artifact として保存しよう

あとは簡単です。

ジョブが成功したかどうかを表すラベル名を `<ジョブの種別>-<ジョブ固有のハッシュ値>.success` とでも定義します。

そして、ジョブの実行開始時に GitHub Actions の artifact としてラベル名のファイルが存在するかを確認します。そしてファイルがあれば処理をスキップし、無ければ処理を継続して成功すれば artifact としてファイルを保存します。ラベル名に意味があるので、ファイルサイズは 0 でかまいません。

過去の artifact の参照して成否を判定するには gh コマンドを用いるのが簡単でよいでしょう。

```sh
exit_code=0
gh run download -n '<ジョブの種別>-<ジョブ固有のハッシュ値>.success' || exit_code=$?
echo "##[set-output name=exit_code;]${exit_code}"
```

GitHub Actions では artifact の保存期限は最長 90 日なので、それ以上過去に実行されたケースではジョブが再実行されてしまいます。要件的に許容することが難しければ S3 や DynamoDB といった外部のストレージの利用を検討するとよさそうです。

## この手法の良いところ、悪いところ

この方法は、大規模で効率的なビルドをするなら Bazel が良いかもしれない。  
けれど Bazel を採用するには大げさかもしれない。しかしビルドやテストを毎回行いたくない…。  
という要求が発端で生まれました。

やっていることは単にあるファイル群から一意なハッシュ値を計算するだけですが、この方法を採用する場合は以下のメリット・デメリットがあるでしょう。

**メリット**

- 既存の言語毎のデファクトスタンダードとなるビルドツールをそのまま使い続けられる
- ハッシュ値を何に活用するかは自分たちの要件で決められる

**デメリット**

- ビルドツールで指定したモジュール間の依存関係を `sver.toml` でも定義してやる必要がある
- ハッシュ値計算以外の作りこみはすべて自分たちで検討する必要がある

一般的にビルドツールや CI/CD 周りの仕組みは「そういうのが好きな開発者」以外はあまり手を付けないものです。  
そのような状況下で monorepo 特有の課題を解決するような専門のビルドツールを持ち込むと様々な問題が出てきます。検索しても知見が集まらない、世の中のスタンダードにうまく乗れない、自分たちの要件にうまくマッチしない時に乗り換えにくいなどです。

一方で monorepo のようなリポジトリのジョブをシンプルな道具だけで開発体験を損なわないようにメンテしていくというというのも簡単なものではありません。

この記事が様々な手法を知ったうえでプロダクトの CI/CD 戦略を決める一助になれば幸いです。

## ジョブに使うソースコードからハッシュ値を計算するツール

さて、ここからはコードリポジトリのハッシュ値を計算するツールの紹介です。  
このツールを紹介するためにはそのモチベーションを説明しなければならないので前置きが長くなってしまいました。

### git コマンドによる解決の課題

[同じ入力に対して一意なラベルをつけよう](#同じ入力に対して一意なラベルをつけよう) では `<ビルドに使われるファイルのリスト>` からハッシュ値を計算するとよいと書きました。しかし、ファイルのリストを一つ一つ手でメンテナンスするのは現実的ではありません。

例えば以下のような monorepo があるとしましょう。

```sh
.
├── README.md
├── doc
│   ├── Design.md
│   └── Roadmap.md
├── libs
│   ├── lib1
│   └── lib2
└── services
     ├── service1
     └── service2
```

例えば `services/service1` のサービスからハッシュ値を計算するにはどうすればいいでしょう。  
簡単に対応するのであれば以下で済むはずです。

```sh
cd services/service1
git ls-files | xargs -I@ cat "@"  | sha256sum
```

しかし `services/service1` が `libs/lib2` に依存していたらどうでしょう？
`libs/lib2` 以下のファイルも依存に含める必要があります。

また、あるタイミングから `libs/lib2` が `libs/lib1` に依存するようになったらどうでしょう？  
`libs/lib1` 以下のファイルも依存に含める必要がありますが `services/service1` の依存ファイルをメンテするときに漏れずに対応できるでしょうか？

![service1 は lib1 に推移的な依存がある](dependency.drawio.svg)

### sver

このようなハッシュ値計算の問題を解決するためのツールが [sver][] です。

[sver][] を用いることで git リポジトリのあるファイルパス下のファイル群のハッシュは以下のように算出できます。

```sh
$ sver calc service/service1
ef5d3d3db6d5 # ← 算出されたハッシュ値
```

またそのディレクトリが別のディレクトリに依存しているときには `sver.toml` という設定ファイルを `services/service1` 以下に配置してやることで推移的にファイルのリストを追加できます。

```toml
[default]
dependencies = [
    "libs/lib2"
]
excludes = []
```

あるタイミングで `libs/lib2` が `libs/lib1` に依存を追加することになったときには `libs/lib2` に以下の `sver.toml` を配置してやるだけで `sver calc service/service1` は推移的に `libs/lib2` と `libs/lib1` のファイルもハッシュ計算に用います。

```toml
[default]
dependencies = [
    "libs/lib1"
]
excludes = []
```

現在は以下の機能/特徴があります

- ファイル実行権限、シンボリックリンク、submodule を考慮したハッシュ計算
- 依存ディレクトリ/ファイルの指定、除外ディレクトリ/ファイルの指定
- sver.toml が循環参照が含む場合も解決可能
- 依存先ファイルの一覧表示 `sver list services/service1`
- リポジトリ内の `sver.toml` に矛盾がないかどうかの検証




[sver]: https://github.com/mitoma/sver
[skip-test-blog]: https://songmu.jp/riji/entry/2021-03-08-utilize-git-tree-hash-in-testing.html
